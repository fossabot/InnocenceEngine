// shadertype=glsl
#version 330 core
layout (location = 0) out vec4 uni_finalColor;

in vec2 TexCoords;

uniform vec3 uni_viewPos;
uniform sampler2D m_gPosition;
uniform sampler2D m_gNormal;
uniform sampler2D m_gAlbedo;
uniform sampler2D m_gSpecular;

struct dirLight {
	vec3 direction;
    vec3 ambientColor;
    vec3 diffuseColor;
    vec3 specularColor;
};

struct pointLight {
	vec3 position;
	float radius;
	float constantFactor;
    float linearFactor;
    float quadraticFactor;

    vec3 ambientColor;
    vec3 diffuseColor;
    vec3 specularColor;
};

const int NR_POINT_LIGHTS = 3;

uniform dirLight uni_dirLight;

uniform pointLight uni_pointLights[NR_POINT_LIGHTS];


vec3 CalcDirLight(dirLight light, vec3 diffuse, vec3 specular, vec3 normal, vec3 viewPos, vec3 fragPos)
{	
	//light direction
	vec3 normalizedLightDir = normalize(-light.direction);

	//view direction
	vec3 normalizedViewDir = normalize(viewPos - fragPos);

	//ambient color
	vec3 ambientColor = diffuse * light.ambientColor * 0.04;

	//diffuse color: texture * factor * light color
	vec3 diffuseColor = diffuse * max(dot(normal, normalizedLightDir), 0.0) * light.diffuseColor;
	
	// specular color: texture * factor * light color
	vec3 specularColor = specular * pow(max(dot(normal, normalize(normalizedLightDir + normalizedViewDir)), 0.0), 32) * light.specularColor;
	
	return (ambientColor + diffuseColor + specularColor) * 0.1;
}

vec3 CalcPointLight(pointLight light, vec3 diffuse, vec3 specular, vec3 normal, vec3 viewPos, vec3 fragPos)
{
	if(length(light.position - fragPos) < light.radius)
	{
	//light direction
	vec3 normalizedLightDir = normalize(light.position - fragPos);

	//view direction
	vec3 normalizedViewDir = normalize(viewPos - fragPos);

	//ambient color
	vec3 ambientColor = diffuse * light.ambientColor * 0.04;

	//diffuse color: texture * factor * light color
	vec3 diffuseColor = diffuse * max(dot(normal, normalizedLightDir), 0.0) * light.diffuseColor;
	
	//specular color: texture * factor * light color
	vec3 specularColor = specular * pow(max(dot(normal, normalize(normalizedLightDir + normalizedViewDir)), 0.0), 32) * light.specularColor;
	
	//attenuation
	float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constantFactor + light.linearFactor * distance + light.quadraticFactor * (distance * distance)); 

	ambientColor  *= attenuation;
    diffuseColor  *= attenuation;
    specularColor *= attenuation;

	return (ambientColor + diffuseColor + specularColor);
	}
	else
	{
	return vec3(0.0f, 0.0f, 0.0f);
	}
}

void main()
{      
    if(texture(m_gPosition, TexCoords).a == 1.0)
    {
	uni_finalColor.a = 0.0;
	}    
	else
	{
	// retrieve data from gbuffer
    vec3 FragPos = texture(m_gPosition, TexCoords).rgb;
	vec3 Diffuse = texture(m_gAlbedo, TexCoords).rgb;
    vec3 Specular = texture(m_gSpecular, TexCoords).rgb;
    vec3 Normal = texture(m_gNormal, TexCoords).rgb;
    
	//final result
	uni_finalColor.rgb = CalcDirLight(uni_dirLight, Diffuse, Specular, Normal, uni_viewPos, FragPos);

	for(int i = 0; i < NR_POINT_LIGHTS; i++)
    {
		uni_finalColor.rgb  += CalcPointLight(uni_pointLights[i], Diffuse, Specular, Normal, uni_viewPos, FragPos);  
	}
	uni_finalColor.a = 1.0;
	}
}
